<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChefVoice AI Assistant</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .ai-orb {
            transition: all 0.5s ease-in-out;
            box-shadow: 0 0 15px rgba(0, 255, 255, 0.5), 0 0 30px rgba(0, 255, 255, 0.3);
        }
        .ai-orb.listening {
            transform: scale(1.1);
            box-shadow: 0 0 25px rgba(255, 255, 100, 0.7), 0 0 50px rgba(255, 255, 100, 0.5);
            background-color: #facc15; /* yellow-400 */
        }
        .ai-orb.thinking {
            animation: spin 1.5s linear infinite;
            box-shadow: 0 0 25px rgba(168, 85, 247, 0.7), 0 0 50px rgba(168, 85, 247, 0.5);
            background-color: #a855f7; /* purple-500 */
        }
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        .chat-bubble-ai {
            background-color: #374151; /* gray-700 */
            border-radius: 20px 20px 20px 5px;
        }
        .chat-bubble-user {
            background-color: #059669; /* emerald-600 */
            border-radius: 20px 20px 5px 20px;
        }
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563; /* gray-600 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }
    </style>
</head>
<body class="bg-gray-900 text-white flex flex-col items-center justify-center min-h-screen p-4">

    <div class="w-full max-w-2xl mx-auto flex flex-col items-center">
        <!-- AI Orb Visualizer -->
        <div id="ai-orb" class="ai-orb w-32 h-32 md:w-40 md:h-40 bg-cyan-500 rounded-full flex items-center justify-center mb-6">
            <svg xmlns="http://www.w3.org/2000/svg" id="mic-icon" class="h-16 w-16 text-gray-900" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M7 4a3 3 0 016 0v4a3 3 0 11-6 0V4zm4 10.93A7.001 7.001 0 0017 8h-1a6 6 0 11-12 0H3a7.001 7.001 0 006 6.93V17H7v1h6v-1h-2v-2.07z" clip-rule="evenodd" />
            </svg>
        </div>
        
        <h1 class="text-3xl md:text-4xl font-bold mb-2">ChefVoice AI</h1>
        <p id="status-text" class="text-gray-400 text-lg mb-4">Click the button to start cooking</p>
        
        <!-- Conversation/Recipe Display -->
        <div id="conversation-display" class="w-full h-64 md:h-80 bg-gray-800 rounded-xl p-4 overflow-y-auto mb-6 border border-gray-700 shadow-lg">
            <!-- Messages will be added here -->
        </div>

        <!-- Microphone Button -->
        <button id="mic-button" class="bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-4 px-8 rounded-full shadow-lg transition-transform transform hover:scale-105 focus:outline-none">
            Start Cooking
        </button>
    </div>

    <script>
        const API_KEY = 'AIzaSyB0KQNuMmZyV2cVfKrgfuscnOJfh475IT0'; // IMPORTANT: PASTE YOUR GOOGLE AI API KEY HERE

        // --- DOM Elements ---
        const micButton = document.getElementById('mic-button');
        const statusText = document.getElementById('status-text');
        const aiOrb = document.getElementById('ai-orb');
        const conversationDisplay = document.getElementById('conversation-display');

        // --- Speech Recognition & Synthesis Setup ---
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        const recognition = new SpeechRecognition();
        recognition.continuous = false;
        recognition.lang = 'en-US';

        const synth = window.speechSynthesis;

        // --- State Management ---
        let state = 'idle'; // idle, listening, thinking, speaking, guiding
        let recipe = {
            ingredients: null,
            instructions: [],
            currentStep: 0,
        };

        // --- UI Update Functions ---
        function setUIState(newState) {
            state = newState;
            aiOrb.classList.remove('listening', 'thinking');
            micButton.disabled = false;
            micButton.textContent = 'Start Cooking';

            switch (state) {
                case 'listening':
                    statusText.textContent = "Listening...";
                    aiOrb.classList.add('listening');
                    micButton.disabled = true;
                    break;
                case 'thinking':
                    statusText.textContent = "Thinking...";
                    aiOrb.classList.add('thinking');
                    micButton.disabled = true;
                    break;
                case 'speaking':
                    statusText.textContent = "ChefVoice is speaking...";
                    micButton.disabled = true;
                    break;
                case 'guiding':
                    micButton.textContent = 'Next Step';
                    statusText.textContent = "Ready for your command...";
                    micButton.disabled = false;
                    break;
                case 'idle':
                default:
                    statusText.textContent = "Click the button to start cooking";
                    break;
            }
        }

        function addMessageToDisplay(text, sender = 'ai') {
            const bubble = document.createElement('div');
            bubble.classList.add('p-3', 'mb-3', 'max-w-md', 'w-fit');
            // Use markdown-like formatting for display
            bubble.innerHTML = text.replace(/\n/g, '<br>').replace(/## (.*?)/g, '<strong>$1</strong>');

            if (sender === 'ai') {
                bubble.classList.add('chat-bubble-ai', 'self-start');
            } else {
                bubble.classList.add('chat-bubble-user', 'self-end', 'ml-auto');
            }
            conversationDisplay.appendChild(bubble);
            conversationDisplay.scrollTop = conversationDisplay.scrollHeight;
        }

        // --- Core Functions ---
        function speak(text, onEndCallback) {
            setUIState('speaking');
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.onend = () => {
                console.log("Speech finished.");
                if (onEndCallback) {
                    onEndCallback();
                } else {
                   setUIState(state === 'guiding' ? 'guiding' : 'idle');
                }
            };
             utterance.onerror = (event) => {
                console.error("SpeechSynthesisUtterance.onerror", event);
                // In case of error, ensure state is reset
                if (onEndCallback) onEndCallback();
                else setUIState(state === 'guiding' ? 'guiding' : 'idle');
            };
            synth.speak(utterance);
        }

        async function generateResponse(command) {
            setUIState('thinking');
            const isRecipeRequest = state !== 'guiding';
            
            const prompt = isRecipeRequest ? 
                `You are ChefVoice, a hands-free AI cooking assistant. A user has asked for a recipe for: "${command}". Generate the recipe with the following strict format: - Start with a title for the recipe. - Use the heading '## Ingredients' followed by a bulleted list of ingredients. - Use the heading '## Instructions' followed by a numbered list of step-by-step instructions. - Do not add any conversational text before the title or after the instructions.`
                : command; // For general conversation, just pass the command

            if (!API_KEY || API_KEY === '') {
                 const errorText = "API Key not configured. Please add your Google AI API key in the script.";
                 addMessageToDisplay(errorText);
                 speak(errorText, () => setUIState('idle'));
                 return;
            }

            try {
                const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${API_KEY}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
                });

                if (!response.ok) {
                    throw new Error(`API request failed with status ${response.status}`);
                }

                const data = await response.json();
                const aiText = data.candidates[0].content.parts[0].text;
                addMessageToDisplay(aiText, 'ai');

                if (isRecipeRequest) {
                    parseAndStartRecipe(aiText);
                } else {
                    speak(aiText, () => setUIState('idle'));
                }

            } catch (error) {
                console.error("Error generating response:", error);
                const errorText = "I'm having trouble thinking right now. Please check the console for errors and try again.";
                addMessageToDisplay(errorText);
                speak(errorText, () => setUIState('idle'));
            }
        }
        
        function parseAndStartRecipe(recipeText) {
            try {
                const parts = recipeText.split('## Instructions');
                const ingredientsPart = parts[0];
                const instructionsPart = parts[1];

                recipe.ingredients = ingredientsPart.replace('## Ingredients', '').trim();
                recipe.instructions = instructionsPart.trim().split('\n').map(step => step.trim()).filter(Boolean);
                recipe.currentStep = 0;

                const intro = `I found a recipe. First, the ingredients. ${recipe.ingredients}. Let me know when you are ready to start cooking.`;
                addMessageToDisplay(intro, 'ai');
                speak(intro, () => setUIState('guiding'));
                
            } catch (e) {
                console.error("Failed to parse recipe:", e);
                const errorText = "I had trouble understanding that recipe format. Let's try another one.";
                addMessageToDisplay(errorText, 'ai');
                speak(errorText, () => setUIState('idle'));
            }
        }

        function handleRecipeStep() {
            if (recipe.currentStep < recipe.instructions.length) {
                const step = recipe.instructions[recipe.currentStep];
                addMessageToDisplay(`Step ${recipe.currentStep + 1}: ${step}`, 'ai');
                
                const isLastStep = recipe.currentStep === recipe.instructions.length - 1;
                const prompt = isLastStep ? "You've completed the final step. Enjoy your meal!" : "Are you ready for the next step?";
                
                speak(`${step}. ${prompt}`, () => {
                    if (isLastStep) {
                        // Reset after final step
                        state = 'idle';
                        setUIState('idle');
                        recipe = { ingredients: null, instructions: [], currentStep: 0 };
                    } else {
                        setUIState('guiding');
                    }
                });
                recipe.currentStep++;
            }
        }
        
        // --- Event Listeners ---
        micButton.addEventListener('click', () => {
            if (state === 'guiding') {
                 // The button acts as "Next Step"
                handleRecipeStep();
            } else {
                recognition.start();
            }
        });

        recognition.onstart = () => {
            setUIState('listening');
        };

        recognition.onresult = (event) => {
            const command = event.results[0][0].transcript;
            addMessageToDisplay(command, 'user');

            if (state === 'guiding') {
                 const lowerCmd = command.toLowerCase();
                 if (lowerCmd.includes('next') || lowerCmd.includes('ready') || lowerCmd.includes('yes')) {
                     handleRecipeStep();
                 } else if (lowerCmd.includes('repeat')) {
                     recipe.currentStep = Math.max(0, recipe.currentStep - 1); // Go back one step
                     handleRecipeStep();
                 } else if (lowerCmd.includes('stop') || lowerCmd.includes('exit')) {
                     speak("Okay, cancelling the recipe.", () => setUIState('idle'));
                     recipe = { ingredients: null, instructions: [], currentStep: 0 };
                 } else {
                    speak("I didn't catch that. Say 'next' to continue or 'stop' to cancel.", () => setUIState('guiding'));
                 }
            } else {
                generateResponse(command);
            }
        };

        recognition.onerror = (event) => {
            console.error("Speech recognition error", event.error);
            statusText.textContent = `Error: ${event.error}. Please try again.`;
            setUIState('idle');

        };

        recognition.onend = () => {
            if (state === 'listening') { // Only reset if we were listening and got no result
               setUIState('idle');
            }
        };

        // Initial setup
        setUIState('idle');

    </script>
</body>
</html>
